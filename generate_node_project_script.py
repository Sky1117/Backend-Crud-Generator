import os
import pandas as pd
import json

# Function to read Excel file and return structured data
def read_excel(file_path):
    try:
        df = pd.read_excel(file_path)
        models = {}
        for _, row in df.iterrows():
            model_name = row['Model']
            if model_name not in models:
                models[model_name] = []
            models[model_name].append({
                'column': row['Column'],
                'datatype': row['Datatype'],
                'depends_on_model': row['Depends on Model'],
                'modal_column': row['Modal Column']
            })
        return models
    except FileNotFoundError:
        print(f"Error: File '{file_path}' not found.")
        return None
    except Exception as e:
        print(f"Error reading the Excel file: {e}")
        return None

# Function to generate model files
def generate_model_files(models):
    for model, columns in models.items():
        with open(f'./models/{model}.js', 'w') as file:
            file.write('const mongoose = require(\'mongoose\');\n')
            file.write(f'const {model}Schema = new mongoose.Schema({{\n')
            for col in columns:
                if col['datatype'] == 'autogenerated Object':
                    continue  # Assuming _id is autogenerated
                if col['column'] == 'attachments':
                    file.write(f'    {col["column"]}: [{col["datatype"]}],\n')  # Array of strings
                else:
                    file.write(f'    {col["column"]}: {{ type: {col["datatype"]} }},\n')

            # Add createdBy and isActive columns
            file.write(f'    createdBy: {{ type: mongoose.Schema.Types.ObjectId, ref: \'User\' }},\n')
            file.write(f'    isActive: {{ type: Boolean, default: true }},\n')

            file.write(f'}}, {{ timestamps: true }});\n')  # Add timestamps option here
            file.write(f'module.exports = mongoose.model(\'{model}\', {model}Schema);\n')

# Function to generate CRUD operations for a model
def generate_crud_controller(model, has_attachments, search_fields):
    search_fields_json = json.dumps(search_fields)
    upload_handler = '''
const handleAttachments = (req) => {
    if (!req.files) return;
    req.body.attachments = req.files.map(file => file.path);
};\n\n''' if has_attachments else ''

    crud_code = f'''
const express = require('express');
const router = express.Router();
const {model} = require('../models/{model}');
const upload = require('../middleware/upload');

// CRUD operations for {model}

{upload_handler}

// Create
router.post('/', upload.array('attachments'), async (req, res) => {{
    {f'handleAttachments(req);' if has_attachments else ''}
    const new{model} = new {model}(req.body);
    try {{
        const saved{model} = await new{model}.save();
        res.status(200).json(saved{model});
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Read all with pagination
router.get('/', async (req, res) => {{
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;
    try {{
        const {model.lower()}s = await {model}.find().skip(skip).limit(limit);
        res.status(200).json({model.lower()}s);
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Read one
router.get('/:id', async (req, res) => {{
    try {{
        const {model.lower()} = await {model}.findById(req.params.id);
        if (!{model.lower()}) {{
            return res.status(404).json({{ error: "No {model} found with this ID." }});
        }}
        res.status(200).json({model.lower()});
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Update
router.put('/:id', upload.array('attachments'), async (req, res) => {{
    {f'handleAttachments(req);' if has_attachments else ''}
    try {{
        const updated{model} = await {model}.findByIdAndUpdate(
            req.params.id,
            {{ $set: req.body }},
            {{ new: true }}
        );
        if (!updated{model}) {{
            return res.status(404).json({{ error: "No {model} found to update." }});
        }}
        res.status(200).json(updated{model});
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Delete
router.delete('/:id', async (req, res) => {{
    try {{
        const deleted{model} = await {model}.findByIdAndDelete(req.params.id);
        if (!deleted{model}) {{
            return res.status(404).json({{ error: "No {model} found to delete." }});
        }}
        res.status(200).json({{ message: "The {model.lower()} has been deleted." }});
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Search with pagination and error handling for invalid queries
router.get('/search', async (req, res) => {{
    const query = {{}};
    let hasValidQuery = false;
    const validFields = new Set({search_fields_json});
    const invalidFields = [];

    Object.keys(req.query).forEach(key => {{
        if (validFields.has(key)) {{
            query[key] = req.query[key];
            hasValidQuery = true;
        }} else {{
            invalidFields.push(key);
        }}
    }});

    if (!hasValidQuery) {{
        return res.status(400).json({{
            error: "No valid search parameters provided.",
            invalidParameters: invalidFields
        }});
    }}

    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;
    try {{
        const results = await {model}.find(query).skip(skip).limit(limit);
        if (!results.length) {{
            return res.status(404).json({{ error: "No results found for the given query." }});
        }}
        res.status(200).json(results);
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

module.exports = router;
'''
    with open(f'./controllers/{model.lower()}.js', 'w') as file:
        file.write(crud_code)

# Function to generate upload middleware
def generate_upload_middleware():
    upload_code = '''
const multer = require('multer');
const path = require('path');
const fs = require('fs');

const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        const dir = './uploads/';
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir);
        }
        cb(null, dir);
    },
    filename: (req, file, cb) => {
        cb(null, file.fieldname + '-' + Date.now() + path.extname(file.originalname));
    }
});

const upload = multer({ storage: storage });

module.exports = upload;
'''
    with open('./middleware/upload.js', 'w') as file:
        file.write(upload_code)

# Function to set up the project
def setup_project(file_path):
    models = read_excel(file_path)
    if models is None:
        return  # Exit if reading the Excel file failed

    os.makedirs('./models', exist_ok=True)
    os.makedirs('./controllers', exist_ok=True)
    os.makedirs('./uploads', exist_ok=True)
    os.makedirs('./middleware', exist_ok=True)  # Directory for middleware

    generate_model_files(models)
    for model, columns in models.items():
        has_attachments = any(col['column'] == 'attachments' for col in columns)
        search_fields = [col['column'] for col in columns if col['column'] != 'attachments']
        generate_crud_controller(model, has_attachments, search_fields)
    generate_upload_middleware()
    print('Project setup complete.')

# File path to the Excel sheet
input_file = 'Testing Model Techhelps.xlsx'  # Replace with the correct path to your Excel file

# Run the project setup
setup_project(input_file)
