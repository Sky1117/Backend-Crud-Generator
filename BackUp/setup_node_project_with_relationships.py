import os
import json  # Add this import
import pandas as pd

# Function to read Excel file and return structured data
def read_excel(file_path):
    df = pd.read_excel(file_path)
    models = {}
    for _, row in df.iterrows():
        model_name = row['Model']
        if model_name not in models:
            models[model_name] = []
        models[model_name].append({
            'column': row['Column'],
            'datatype': row['Datatype'],
            'depends_on_model': row['Depends on Model'],
            'modal_column': row['Modal Column']
        })
    return models

# Function to generate model files with relationships based on depends_on_model and modal_column
def generate_model_files(models):
    data_type_mapping = {
        'String': 'String',
        'Number': 'Number',
        'Boolean': 'Boolean',
        'Date': 'Date',
        'Array': '[String]',  # Adjust if array type needs to be different
        # Add more data types as needed
    }

    for model, columns in models.items():
        with open(f'./models/{model}.js', 'w') as file:
            file.write('const mongoose = require(\'mongoose\');\n')
            file.write(f'const {model}Schema = new mongoose.Schema({{\n')
            for col in columns:
                if col['datatype'] == 'autogenerated Object':
                    continue  # Assuming _id is autogenerated

                if pd.notna(col['depends_on_model']) and pd.notna(col['modal_column']):
                    # Handling relationship only if both depends_on_model and modal_column are defined
                    ref_model = col['depends_on_model']
                    file.write(f'    {col["column"]}: {{ type: mongoose.Schema.Types.ObjectId, ref: \'{ref_model}\' }},\n')
                else:
                    # Use specified data type
                    data_type = data_type_mapping.get(col['datatype'], 'String')  # Default to String if datatype not found
                    file.write(f'    {col["column"]}: {{ type: {data_type} }},\n')
            file.write(f'}}, {{ timestamps: true }});\n')  # Add timestamps option here
            file.write(f'module.exports = mongoose.model(\'{model}\', {model}Schema);\n')

# Function to generate CRUD operations for a model
def crud_operations(model, has_attachments, search_fields):
    search_fields_json = json.dumps(search_fields)
    pagination_code = '''
const page = parseInt(req.query.page) || 1;
const limit = parseInt(req.query.limit) || 10;
const skip = (page - 1) * limit;
'''
    return f'''
// CRUD operations for {model}
// Create
router.post('/{model.lower()}', async (req, res) => {{
    const new{model} = new {model}(req.body);
    try {{
        const saved{model} = await new{model}.save();
        res.status(200).json(saved{model});
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Read all with pagination
router.get('/{model.lower()}', async (req, res) => {{
    {pagination_code}
    try {{
        const {model.lower()} = await {model}.find().skip(skip).limit(limit);
        res.status(200).json({model.lower()});
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Read one
router.get('/{model.lower()}/:id', async (req, res) => {{
    try {{
        const {model.lower()} = await {model}.findById(req.params.id);
        if (!{model.lower()}) {{
            return res.status(404).json("The {model.lower()} was not found.");
        }}
        res.status(200).json({model.lower()});
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Update
router.put('/{model.lower()}/:id', async (req, res) => {{
    try {{
        const updated{model} = await {model}.findByIdAndUpdate(
            req.params.id,
            {{ $set: req.body }},
            {{ new: true }}
        );
        if (!updated{model}) {{
            return res.status(404).json("The {model.lower()} was not found.");
        }}
        res.status(200).json(updated{model});
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Delete
router.delete('/{model.lower()}/:id', async (req, res) => {{
    try {{
        const deleted{model} = await {model}.findByIdAndDelete(req.params.id);
        if (!deleted{model}) {{
            return res.status(404).json("The {model.lower()} was not found.");
        }}
        res.status(200).json("The {model.lower()} has been deleted.");
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Search with pagination and validation
router.get('/{model.lower()}/search', async (req, res) => {{
    const query = {{}};
    let hasValidQuery = false;
    const validFields = new Set({search_fields_json});
    const invalidFields = [];

    Object.keys(req.query).forEach(key => {{
        if (validFields.has(key)) {{
            query[key] = req.query[key];
            hasValidQuery = true;
        }} else {{
            invalidFields.push(key);
        }}
    }});

    if (!hasValidQuery) {{
        return res.status(400).json({{
            error: "No valid search parameters provided.",
            invalidParameters: invalidFields
        }});
    }}

    {pagination_code}
    try {{
        const results = await {model}.find(query).skip(skip).limit(limit);
        if (!results.length) {{
            return res.status(404).json({{ error: "No results found for the given query." }});
        }}
        res.status(200).json(results);
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});
'''

# Function to generate a controller file with CRUD operations
def generate_controller_file(models):
    with open('./controllers/controller.js', 'w') as file:
        file.write("const express = require('express');\n")
        file.write("const router = express.Router();\n")
        file.write("const multer = require('multer');\n")
        file.write("const upload = multer({ dest: 'uploads/' });\n")
        file.write("\n")
        for model in models.keys():
            file.write(f"const {model} = require('../models/{model}');\n")
        file.write("\n")
        for model, columns in models.items():
            has_attachments = any(col['column'] == 'attachments' for col in columns)
            search_fields = [col['column'] for col in columns if col['column'] != 'attachments']
            file.write(crud_operations(model, has_attachments, search_fields))
        file.write("\nmodule.exports = router;\n")

# Main function to set up the project
def setup_project(file_path):
    # Read model data from Excel
    models = read_excel(file_path)

    # Create necessary directories
    os.makedirs('./models', exist_ok=True)
    os.makedirs('./controllers', exist_ok=True)
    os.makedirs('./uploads', exist_ok=True)  # Directory for file uploads

    # Generate model files with relationships and proper data types
    generate_model_files(models)

    # Generate controller file with CRUD operations
    generate_controller_file(models)

    print('Project setup complete.')

# File path to the Excel sheet
excel_file_path = 'Testing Model Techhelps.xlsx'  # Replace with actual path

# Run the project setup
setup_project(excel_file_path)
