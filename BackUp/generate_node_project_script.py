import os
import pandas as pd
import json

# Function to read Excel file and return structured data
def read_excel(file_path):
    df = pd.read_excel(file_path)
    models = {}
    for _, row in df.iterrows():
        model_name = row['Model']
        if model_name not in models:
            models[model_name] = []
        models[model_name].append({
            'column': row['Column'],
            'datatype': row['Datatype'],
            'depends_on_model': row['Depends on Model'],
            'modal_column': row['Modal Column']
        })
    return models

# Function to generate model files
def generate_model_files(models):
    for model, columns in models.items():
        with open(f'./models/{model}.js', 'w') as file:
            file.write('const mongoose = require(\'mongoose\');\n')
            file.write(f'const {model}Schema = new mongoose.Schema({{\n')
            for col in columns:
                if col['datatype'] == 'autogenerated Object':
                    continue  # Assuming _id is autogenerated
                if col['column'] == 'attachments':
                    file.write(f'    {col["column"]}: [{col["datatype"]}],\n')  # Array of strings
                else:
                    file.write(f'    {col["column"]}: {{ type: {col["datatype"]} }},\n')
            file.write(f'}}, {{ timestamps: true }});\n')  # Add timestamps option here
            file.write(f'module.exports = mongoose.model(\'{model}\', {model}Schema);\n')

# Function to generate CRUD operations for a model
def crud_operations(model, has_attachments, search_fields):
    search_fields_json = json.dumps(search_fields)

    if has_attachments:
        return f'''
// CRUD operations for {model}
// Create
router.post('/{model.lower()}', upload.array('attachments'), async (req, res) => {{
    handleAttachments(req);
    const new{model} = new {model}(req.body);
    try {{
        const saved{model} = await new{model}.save();
        res.status(200).json(saved{model});
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Read all with pagination
router.get('/{model.lower()}', async (req, res) => {{
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;
    try {{
        const {model.lower()} = await {model}.find().skip(skip).limit(limit);
        res.status(200).json({model.lower()});
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Read one
router.get('/{model.lower()}/:id', async (req, res) => {{
    try {{
        const {model.lower()} = await {model}.findById(req.params.id);
        if (!{model.lower()}) {{
            return res.status(404).json({{ error: "No {model} found with this ID." }});
        }}
        res.status(200).json({model.lower()});
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Update
router.put('/{model.lower()}/:id', upload.array('attachments'), async (req, res) => {{
    handleAttachments(req);
    try {{
        const updated{model} = await {model}.findByIdAndUpdate(
            req.params.id,
            {{ $set: req.body }},
            {{ new: true }}
        );
        if (!updated{model}) {{
            return res.status(404).json({{ error: "No {model} found to update." }});
        }}
        res.status(200).json(updated{model});
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Delete
router.delete('/{model.lower()}/:id', async (req, res) => {{
    try {{
        const deleted{model} = await {model}.findByIdAndDelete(req.params.id);
        if (!deleted{model}) {{
            return res.status(404).json({{ error: "No {model} found to delete." }});
        }}
        res.status(200).json({{ message: "The {model.lower()} has been deleted." }});
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Search with pagination and error handling for invalid queries
router.get('/{model.lower()}/search', async (req, res) => {{
    const query = {{}};
    let hasValidQuery = false;
    const validFields = new Set({search_fields_json});
    const invalidFields = [];

    Object.keys(req.query).forEach(key => {{
        if (validFields.has(key)) {{
            query[key] = req.query[key];
            hasValidQuery = true;
        }} else {{
            invalidFields.push(key);
        }}
    }});

    if (!hasValidQuery) {{
        return res.status(400).json({{
            error: "No valid search parameters provided.",
            invalidParameters: invalidFields
        }});
    }}

    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;
    try {{
        const results = await {model}.find(query).skip(skip).limit(limit);
        if (!results.length) {{
            return res.status(404).json({{ error: "No results found for the given query." }});
        }}
        res.status(200).json(results);
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});
'''
    else:
        return f'''
// CRUD operations for {model}
// Create
router.post('/{model.lower()}', async (req, res) => {{
    const new{model} = new {model}(req.body);
    try {{
        const saved{model} = await new{model}.save();
        res.status(200).json(saved{model});
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Read all with pagination
router.get('/{model.lower()}', async (req, res) => {{
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;
    try {{
        const {model.lower()} = await {model}.find().skip(skip).limit(limit);
        res.status(200).json({model.lower()});
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Read one
router.get('/{model.lower()}/:id', async (req, res) => {{
    try {{
        const {model.lower()} = await {model}.findById(req.params.id);
        if (!{model.lower()}) {{
            return res.status(404).json({{ error: "No {model} found with this ID." }});
        }}
        res.status(200).json({model.lower()});
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Update
router.put('/{model.lower()}/:id', async (req, res) => {{
    try {{
        const updated{model} = await {model}.findByIdAndUpdate(
            req.params.id,
            {{ $set: req.body }},
            {{ new: true }}
        );
        if (!updated{model}) {{
            return res.status(404).json({{ error: "No {model} found to update." }});
        }}
        res.status(200).json(updated{model});
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Delete
router.delete('/{model.lower()}/:id', async (req, res) => {{
    try {{
        const deleted{model} = await {model}.findByIdAndDelete(req.params.id);
        if (!deleted{model}) {{
            return res.status(404).json({{ error: "No {model} found to delete." }});
        }}
        res.status(200).json({{ message: "The {model.lower()} has been deleted." }});
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});

// Search with pagination and error handling for invalid queries
router.get('/{model.lower()}/search', async (req, res) => {{
    const query = {{}};
    let hasValidQuery = false;
    const validFields = new Set({search_fields_json});
    const invalidFields = [];

    Object.keys(req.query).forEach(key => {{
        if (validFields.has(key)) {{
            query[key] = req.query[key];
            hasValidQuery = true;
        }} else {{
            invalidFields.push(key);
        }}
    }});

    if (!hasValidQuery) {{
        return res.status(400).json({{
            error: "No valid search parameters provided.",
            invalidParameters: invalidFields
        }});
    }}

    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;
    try {{
        const results = await {model}.find(query).skip(skip).limit(limit);
        if (!results.length) {{
            return res.status(404).json({{ error: "No results found for the given query." }});
        }}
        res.status(200).json(results);
    }} catch (err) {{
        res.status(500).json(err);
    }}
}});
'''

# Function to generate a controller file with CRUD operations
def generate_controller_file(models):
    with open('./controllers/controller.js', 'w') as file:
        file.write("const express = require('express');\n")
        file.write("const router = express.Router();\n")
        file.write("const multer = require('multer');\n")
        file.write("const upload = multer({ dest: 'uploads/' });\n")
        file.write("\n")
        for model in models.keys():
            file.write(f"const {model} = require('../models/{model}');\n")
        file.write("\n")
        file.write("const handleAttachments = (req) => {\n")
        file.write("    if (req.files && req.files.length) {\n")
        file.write("        req.body.attachments = req.files.map(file => file.path);\n")
        file.write("    }\n};\n\n")
        for model, columns in models.items():
            has_attachments = any(col['column'] == 'attachments' for col in columns)
            search_fields = [col['column'] for col in columns if col['column'] != 'attachments']
            file.write(crud_operations(model, has_attachments, search_fields))
        file.write("\nmodule.exports = router;\n")

# Function to set up the project
def setup_project(file_path):
    # Read model data from Excel
    models = read_excel(file_path)

    # Create necessary directories
    os.makedirs('./models', exist_ok=True)
    os.makedirs('./controllers', exist_ok=True)
    os.makedirs('./uploads', exist_ok=True)  # Directory for file uploads

    # Generate model files
    generate_model_files(models)

    # Generate controller file with CRUD operations
    generate_controller_file(models)

    print('Project setup complete.')

# File path to the Excel sheet
excel_file_path = 'Testing Model Techhelps.xlsx'  # Replace with actual path

# Run the project setup
setup_project(excel_file_path)
